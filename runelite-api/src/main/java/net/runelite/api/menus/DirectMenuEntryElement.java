package net.runelite.api.menus;

import java.util.function.Consumer;
import lombok.Getter;
import net.runelite.api.MenuEntry;
import static net.runelite.api.MenuOpcode.MENU_ACTION_DEPRIORITIZE_OFFSET;
import net.runelite.api.util.Text;
import org.apache.commons.lang3.StringUtils;

/**
 * Don't forget that this class is shared between
 * every class wanting to use this. Don't expect
 * it's idx to be the same as when you left it,
 * and don't try to sneakily sneak in some multi
 * threading, as that would pretty much break everything
 * and we all know that's not fun.
 */
public class DirectMenuEntryElement extends MenuEntries
{
	/**
	 * Whenever you need to do something with this class, this
	 * is where you're going to have to get it. Unless it's shadowed
	 * somewhere else by then, cause then you'd also be able to get it
	 * there. I've probably already added it somewhere else by now tbh
	 */
	public static final DirectMenuEntryElement INSTANCE = new DirectMenuEntryElement(0);

	/**
	 * Can't break things if you can't touch em :smart:
	 */
	private DirectMenuEntryElement(int idx)
	{
		this.idx = idx;
	}

	/**
	 * Gets the instance and sets it to the correct index
	 * immediately. Wow, computers!
	 */
	public static DirectMenuEntryElement get(int idx)
	{
		return INSTANCE.jumpTo(idx);
	}

	/**
	 * The index in the menuEntry arrays this object represents
	 * right now. Think of it as what was in between the '[]'
	 * when MenuEntry[]s still were a thing
	 */
	@Getter
	private int idx;

	/**
	 * Next methods are all the same as they used to be for
	 * MenuEntries. if you don't count some of the names that is,
	 * but you shouldn't as they're way more accurate now and
	 * the way they were only served to confuse whoever fell
	 * into the trap of fixing menumanager that time.
	 */
	public int getIdentifier()
	{
		return menuIdentifiers[idx];
	}

	public void setIdentifier(int id)
	{
		menuIdentifiers[idx] = id;
	}

	public int getActionParam0()
	{
		return menuArguments1[idx];
	}

	public void setActionParam0(int p0)
	{
		menuArguments1[idx] = p0;
	}

	public int getActionParam1()
	{
		return menuArguments2[idx];
	}

	public void setActionParam1(int p1)
	{
		menuArguments1[idx] = p1;
	}

	public boolean getShiftClick()
	{
		return menuShiftClick[idx];
	}

	public void setShiftClick(boolean shiftClick)
	{
		menuShiftClick[idx] = shiftClick;
	}

	public int getOpcode()
	{
		return menuOpcodes[idx];
	}

	public void setOpcode(int p1)
	{
		menuOpcodes[idx] = p1;
	}

	public String getOption()
	{
		return menuOptions[idx];
	}

	public void setOption(String opt)
	{
		menuOptions[idx] = opt;
	}

	public String getTarget()
	{
		return menuTargets[idx];
	}

	public void setTarget(String opt)
	{
		menuTargets[idx] = opt;
	}

	/**
	 * (Pretty much) every field here has one of
	 * these methods right here, so we can keep all
	 * objects in their arrays when comparing them.
	 * That way we don't suddenly end up with 10000
	 * different strings floating around cause someone
	 * is training pickpocketing nearby or something.
	 * <p>
	 * Not even sure what that last part means either tbh
	 */
	public boolean idEquals(int id)
	{
		return menuIdentifiers[idx] == id;
	}

	public boolean arg1Equals(int arg1)
	{
		return menuArguments1[idx] == arg1;
	}

	public boolean arg2Equals(int arg1)
	{
		return menuArguments2[idx] == arg1;
	}

	public boolean opcodeEquals(int arg1)
	{
		return menuOpcodes[idx] == arg1;
	}

	public boolean shiftEquals(boolean shift)
	{
		return menuShiftClick[idx] == shift;
	}

	/*
	 * WHAT, NO STANDARDIZE()?!?!?!??!
	 *
	 * Nope, options are always uncoloured, so removing
	 * tags is useless. Just yoink from stringutils lol
	 */
	public boolean optionEquals(String option)
	{
		return menuOptions[idx].equalsIgnoreCase(option);
	}

	public boolean optionContains(String option)
	{
		return StringUtils.containsIgnoreCase(menuOptions[idx], (option));
	}

	/**
	 * The standardize method used here probably works well enough
	 * to be able to use it on everything generated by game. Don't
	 * accidentally use it on human generated (aka probably dirty
	 * with all kinds of whitespace in places it doesn't belong)
	 * strings, unless you want it to not work correctly. If that's
	 * what you want, I would like to point out that's not what
	 * I wrote that method for and it's pretty rude to say otherwise
	 */
	public boolean targetEquals(String option)
	{
		return Text.standardize(menuTargets[idx]).equals(option);
	}

	public boolean targetContains(String option)
	{
		return Text.standardize(menuTargets[idx]).contains(option);
	}

	/**
	 * Wait... Next? Do I smell an iterator?
	 * <p>
	 * Answer to that is kinda, kinda not. This class
	 * can behave, look, act, talk, walk, dance,
	 * sleep and eat like a iterator, but that would
	 * work in all kinds of wacky ways.
	 * <p>
	 * If someone wants to implement it so they can do
	 * for (DirectMenuEntryElement : (i don't know)),
	 * feel free.
	 * <p>
	 * I don't know if you guessed it btw, but this method
	 * increases the idx in the menu array with 1. Make sure
	 * to use hasNext first though!
	 */
	public DirectMenuEntryElement next()
	{
		assert idx + 1 < menuEntryCount;
		idx++;
		return this;
	}

	/**
	 * Just another fake knockoff brand iterator method.
	 * Tells you if the menu entry you've got 'selected'
	 * right now is the last one.
	 */
	public boolean hasNext()
	{
		return idx + 1 < menuEntryCount;
	}

	/**
	 * If you thought this was like next() you've got it
	 * all backwards..  .
	 * <p>
	 * I'll leave this one here
	 */
	public DirectMenuEntryElement previous()
	{
		assert idx >= 1;
		idx--;
		return this;
	}

	/**
	 * I usually say had previous, but whatever floats
	 * your fake iterator class I guess
	 */
	public boolean hasPrevious()
	{
		return idx > 1;
	}

	/**
	 * The only reason this class exists is cause MenuManager was too slow
	 * What else to implement than pretty much the slowest thing in java?!
	 *
	 * For real though, this iterates over all elements, from bottom down,
	 * applying your lambda to every one of them on the way.
	 */
	public DirectMenuEntryElement forEach(Consumer<DirectMenuEntryElement> consumer)
	{
		for (idx = 0; idx < menuEntryCount; idx++)
		{
			consumer.accept(this);
		}

		return this;
	}

	/**
	 * Basically the same thing as the previous method; just backwards.
	 *
	 * This usually is what you're looking for though, seeing how the last added one is the
	 * one that's on top of the menu entry list
	 */
	public DirectMenuEntryElement hcaErof(Consumer<DirectMenuEntryElement> consumer)
	{
		for (idx = menuEntryCount; idx > 0; idx--)
		{
			consumer.accept(this);
		}

		return this;
	}

	/**
	 * Gets the last (the top) menu entry
	 */
	public static DirectMenuEntryElement getLast()
	{
		return INSTANCE.jumpTo(menuEntryCount - 1);
	}

	/**
	 * Sets the current index to idx. Pretty much a fail-fast setter
	 * for the index. If you don't do this you may end up in indices
	 * which aren't filled, and the client isn't going to drawn cause
	 * of that. Wasted effort and all that
	 */
	public DirectMenuEntryElement jumpTo(int idx)
	{
		if (idx >= menuEntryCount || idx < 0)
		{
			throw new ArrayIndexOutOfBoundsException(idx + " isn't in between " + menuEntryCount + " and 0");
		}
		this.idx = idx;
		return this;
	}

	/**
	 * This exists as a semi-replacement for MenuUtil swap
	 * should probably still be used sparingly
	 */
	public void swapWith(String option)
	{
		for (int i = menuEntryCount; i > 0; i--)
		{
			if (!menuOptions[i].equalsIgnoreCase(option))
			{
				continue;
			}

			if (!menuTargets[i].equals(menuTargets[idx]))
			{
				continue;
			}

			String tmp = menuOptions[i];
			menuOptions[i] = menuOptions[idx];
			menuOptions[idx] = tmp;

			int temp = menuArguments1[i];
			menuArguments1[i] = menuArguments1[idx];
			menuArguments1[idx] = temp;

			temp = menuArguments2[i];
			menuArguments2[i] = menuArguments2[idx];
			menuArguments2[idx] = temp;

			temp = menuIdentifiers[i];
			menuIdentifiers[i] = menuIdentifiers[idx];
			menuIdentifiers[idx] = temp;

			temp = menuOpcodes[i];
			menuOpcodes[i] = menuOpcodes[idx];
			menuOpcodes[idx] = temp;

			return;
		}
	}

	public void swapWith(int other)
	{
		String tmp = menuOptions[other];
		menuOptions[other] = menuOptions[idx];
		menuOptions[idx] = tmp;

		int temp = menuArguments1[other];
		menuArguments1[other] = menuArguments1[idx];
		menuArguments1[idx] = temp;

		temp = menuArguments2[other];
		menuArguments2[other] = menuArguments2[idx];
		menuArguments2[idx] = temp;

		temp = menuIdentifiers[other];
		menuIdentifiers[other] = menuIdentifiers[idx];
		menuIdentifiers[idx] = temp;

		temp = menuOpcodes[other];
		menuOpcodes[other] = menuOpcodes[idx];
		menuOpcodes[idx] = temp;
	}

	public void shiftDown()
	{
		shiftDown(1);
	}

	public void shiftDown(int amt)
	{
		final int newIdx = idx - amt;
		menuArguments1[newIdx] = menuArguments1[idx];
		menuArguments2[newIdx] = menuArguments2[idx];
		menuOpcodes[newIdx] = menuOpcodes[idx];
		menuIdentifiers[newIdx] = menuIdentifiers[idx];
		menuOptions[newIdx] = menuOptions[idx];
		menuTargets[newIdx] = menuTargets[idx];
		menuShiftClick[newIdx] = menuShiftClick[idx];
		idx = newIdx;
	}

	public void insertBefore(MenuEntry entry)
	{
		// Budget shiftUp?
		shiftDown(-1);
		// reset idx to before shift
		idx--;
		menuArguments1[idx] = entry.getActionParam0();
		menuArguments2[idx] = entry.getActionParam1();
		menuOpcodes[idx] = entry.getOpcode();
		menuIdentifiers[idx] = entry.getIdentifier();
		menuOptions[idx] = entry.getOption();
		menuTargets[idx] = entry.getTarget();
		menuShiftClick[idx] = false;
		// Make sure to increase count
		getClient().setMenuOptionCount(++menuEntryCount);
	}

	/**
	 * Adds the magic number (not really magic though is it)
	 * of 2000 to the opcode of the current entry, meaning it'll
	 * BOTH get shifted down (or up?) the list AND it'll work
	 * exactly the same! Bonus!
	 */
	public void deprioritize()
	{
		menuOpcodes[idx] += MENU_ACTION_DEPRIORITIZE_OFFSET;
	}
}